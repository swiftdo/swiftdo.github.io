(window.webpackJsonp=window.webpackJsonp||[]).push([[247],{682:function(t,n,s){"use strict";s.r(n);var l=s(2),v=Object(l.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("结构化并发（Structured Concurrency）是一种编程模型，旨在简化并发代码的编写和管理，并降低并发编程中的一些常见错误。结构化并发通过引入一套规范，使得并发操作在代码中有着明确定义的层次结构，从而使并发代码更易于理解、调试和维护。")]),t._v(" "),n("p",[t._v("在传统的非结构化并发中，开发人员需要手动创建和管理线程或任务，并负责处理并发操作和同步问题。这往往导致代码复杂、容易出错，难以维护。而结构化并发则提供了更高级别的抽象，以简化并发代码的编写和组织。")]),t._v(" "),n("p",[t._v("结构化并发的主要特点包括：")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("异步/等待（async/await）：结构化并发引入了异步/等待模式，允许开发人员使用 async 关键字定义异步函数，其中可以使用 await 关键字等待异步操作的结果。这使得异步代码看起来像是同步代码，更易于阅读和理解。")])]),t._v(" "),n("li",[n("p",[t._v("结构化任务（Task）：结构化并发中的任务（Task）是一个重要的概念，表示一个可以独立执行的代码块。任务可以是异步的，也可以是同步的。任务可以有父任务，从而形成明确的层次结构。")])]),t._v(" "),n("li",[n("p",[t._v("作用域绑定（Scope-Bound）：结构化并发中的任务可以通过作用域绑定来确保在任务范围内的任务和资源的生命周期。这可以帮助避免资源泄漏和明确任务的生命周期。")])]),t._v(" "),n("li",[n("p",[t._v("全局任务（Global Actors）：结构化并发中的全局任务是一种机制，用于保证特定代码块在执行时是独占的，从而避免了并发问题，例如竞态条件。")])]),t._v(" "),n("li",[n("p",[t._v("异步序列（Async Sequences）：结构化并发引入了异步序列，用于处理返回多个值的异步操作。异步序列可以异步地迭代，从而更有效地处理大量数据或流式数据。")])])]),t._v(" "),n("p",[t._v("结构化并发的目标是提供更简单、更安全、更直观的并发编程模型，使得开发人员可以更轻松地编写高效且易于维护的并发代码。在 Swift 编程语言中，引入了结构化并发模型来实现这些功能。")])])}),[],!1,null,null,null);n.default=v.exports}}]);