(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{538:function(v,t,e){"use strict";e.r(t);var _=e(4),s=Object(_.a)({},(function(){var v=this,t=v.$createElement,e=v._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("p",[v._v("一些经典的设计原则，其中包括，SOLID，KISS, YAGNI, DRY, LOD")]),v._v(" "),e("h2",{attrs:{id:"solid"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#solid"}},[v._v("#")]),v._v(" SOLID")]),v._v(" "),e("h3",{attrs:{id:"s-单一职责"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#s-单一职责"}},[v._v("#")]),v._v(" S：单一职责")]),v._v(" "),e("blockquote",[e("p",[v._v("Single Responsibility Principle\nA class or module should have a single reponsibility")])]),v._v(" "),e("p",[v._v("一个类或者模块只负责完成一个职责（或者功能）")]),v._v(" "),e("p",[v._v("一个类，应该只有一个引起它变化的原因")]),v._v(" "),e("p",[v._v("关于编程有这样一个最佳实践：一个类文件打开后，最好不要超过屏幕的一屏。这样做的好处是，一方面代码少，职责单一，可以更容易地进行复用和扩展，更符合开闭原则。另一方面，阅读简单，维护方便。")]),v._v(" "),e("p",[v._v("不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：")]),v._v(" "),e("ul",[e("li",[v._v("类中的代码行数、函数或者属性过多；")]),v._v(" "),e("li",[v._v("类依赖的其他类过多，或者依赖类的其他类过多；")]),v._v(" "),e("li",[v._v("私有方法过多；比较难给类起一个合适的名字；")]),v._v(" "),e("li",[v._v("类中大量的方法都是集中操作类中的某几个属性。")])]),v._v(" "),e("h3",{attrs:{id:"o-开闭原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#o-开闭原则"}},[v._v("#")]),v._v(" O：开闭原则")]),v._v(" "),e("blockquote",[e("p",[v._v("Open Closed Principle\nsoftware entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。")])]),v._v(" "),e("p",[v._v("软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。")]),v._v(" "),e("p",[v._v("通俗的说就是，软件功能可以扩展，但是软件实体不可以被修改。")]),v._v(" "),e("p",[v._v("实现开闭原则的关键是抽象。当一个模块依赖的是一个抽象接口的时候，就可以随意对这个抽象接口进行扩展，这个时候，不需要对现有代码进行任何修改，利用接口的多态性，通过增加一个新实现该接口的实现类，就能完成需求变更。不同场景进行扩展的方式是不同的，这时候就会产生不同的设计模式，大部分的设计模式都是用来解决扩展的灵活性问题的")]),v._v(" "),e("h3",{attrs:{id:"l-里是替换原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#l-里是替换原则"}},[v._v("#")]),v._v(" L：里是替换原则")]),v._v(" "),e("blockquote",[e("p",[v._v("Liskov Substitution Principle\nFunctions that use pointers of references to base classes must be able to use objects of derived classes without knowing it")])]),v._v(" "),e("p",[v._v("子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。")]),v._v(" "),e("p",[v._v("多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。")]),v._v(" "),e("p",[v._v("实践中，当你继承一个父类仅仅是为了复用父类中的方法的时候，那么很有可能你离错误的继承已经不远了。一个类如果不是为了被继承而设计，那么最好就不要继承它。粗暴一点地说，如果不是抽象类或者接口，最好不要继承它。")]),v._v(" "),e("h3",{attrs:{id:"i-接口隔离原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#i-接口隔离原则"}},[v._v("#")]),v._v(" I：接口隔离原则")]),v._v(" "),e("blockquote",[e("p",[v._v("Interface Segregation Principle\nClients should not be forced to depend upon interfaces that they do not use")])]),v._v(" "),e("p",[v._v("客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。")]),v._v(" "),e("p",[v._v("理解接口隔离原则的关键，就是理解其中的“接口”二字。在这条原则中，我们可以把“接口”理解为下面三种东西：")]),v._v(" "),e("ul",[e("li",[v._v("一组 API 接口集合")]),v._v(" "),e("li",[v._v("单个 API 接口或函数")]),v._v(" "),e("li",[v._v("OOP 中的接口概念")])]),v._v(" "),e("h3",{attrs:{id:"d-依赖倒置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#d-依赖倒置"}},[v._v("#")]),v._v(" D：依赖倒置")]),v._v(" "),e("blockquote",[e("p",[v._v("High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.")])]),v._v(" "),e("p",[v._v("高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。")]),v._v(" "),e("p",[v._v("依赖倒置原则:")]),v._v(" "),e("ul",[e("li",[v._v("高层模块不应该依赖低层模块，二者都应该依赖抽象。")]),v._v(" "),e("li",[v._v("抽象不应该依赖具体实现，具体实现应该依赖抽象。每个高层模块都为它所需要的服务声明一个抽象接口，而低层模块则实现这些抽象接口，高层模块通过抽象接口使用低层模块。这样，高层模块就不需要直接依赖低层模块，而变成了低层模块依赖高层模块定义的抽象接口，从而实现了依赖倒置，解决了策略层、方法层、工具层的传递依赖问题。")])]),v._v(" "),e("p",[v._v("遵循依赖倒置原则有这样几个编码守则：")]),v._v(" "),e("ul",[e("li",[v._v("应用代码中多使用抽象接口，尽量避免使用那些多变的具体实现类。")]),v._v(" "),e("li",[v._v("不要继承具体类，如果一个类在设计之初不是抽象类，那么尽量不要去继承它。")]),v._v(" "),e("li",[v._v("对具体类的继承是一种强依赖关系，维护的时候难以改变。不要重写（override）包含具体实现的函数。")])]),v._v(" "),e("p",[v._v("几个概念的对比：")]),v._v(" "),e("ul",[e("li",[v._v("控制反转实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。")]),v._v(" "),e("li",[v._v("依赖注入依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。")]),v._v(" "),e("li",[v._v("依赖注入框架我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。")]),v._v(" "),e("li",[v._v("依赖反转原则，这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。")])]),v._v(" "),e("h2",{attrs:{id:"kiss"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#kiss"}},[v._v("#")]),v._v(" KISS")]),v._v(" "),e("blockquote",[e("p",[v._v("英文描述有好几个版本\nKeep It Simple and Stupid.\nKeep It Short and Simple.\nKeep It Simple and Straightforward.")])]),v._v(" "),e("p",[v._v("尽量保持简单")]),v._v(" "),e("p",[v._v("如何写出满足 KISS 原则的代码？")]),v._v(" "),e("ul",[e("li",[v._v("不要使用同事可能不懂的技术来实现代码。")]),v._v(" "),e("li",[v._v("不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。")]),v._v(" "),e("li",[v._v("不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。")])]),v._v(" "),e("h2",{attrs:{id:"yagni"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#yagni"}},[v._v("#")]),v._v(" YAGNI")]),v._v(" "),e("blockquote",[e("p",[v._v("You Ain’t Gonna Need It")])]),v._v(" "),e("p",[v._v("你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计")]),v._v(" "),e("h2",{attrs:{id:"dry"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dry"}},[v._v("#")]),v._v(" DRY")]),v._v(" "),e("blockquote",[e("p",[v._v("Don’t Repeat Yourself")])]),v._v(" "),e("p",[v._v("三种典型的代码重复情况，它们分别是：实现逻辑重复、功能语义重复和代码执行重复。")]),v._v(" "),e("p",[v._v("提高代码可复用性的一些方法，有以下 7 点：")]),v._v(" "),e("ul",[e("li",[v._v("减少代码耦合")]),v._v(" "),e("li",[v._v("满足单一职责原则")]),v._v(" "),e("li",[v._v("模块化")]),v._v(" "),e("li",[v._v("业务与非业务逻辑分离")]),v._v(" "),e("li",[v._v("通用代码下沉")]),v._v(" "),e("li",[v._v("继承、多态、抽象、封装")]),v._v(" "),e("li",[v._v("应用模板等设计模式")])]),v._v(" "),e("h2",{attrs:{id:"lod"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lod"}},[v._v("#")]),v._v(" LOD")]),v._v(" "),e("blockquote",[e("p",[v._v("迪米特法则 最小知识原则（Law of Demeter）")])]),v._v(" "),e("p",[v._v("或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。")]),v._v(" "),e("p",[v._v("利用这个原则，能够帮我们实现代码的“高内聚、松耦合”")]),v._v(" "),e("ul",[e("li",[v._v("所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。实际上，单一职责原则是实现代码高内聚非常有效的设计原则。")]),v._v(" "),e("li",[v._v("所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。实际上，我们前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及迪米特法则，都是为了实现代码的松耦合。")])])])}),[],!1,null,null,null);t.default=s.exports}}]);