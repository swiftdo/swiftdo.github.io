(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{552:function(v,_,t){"use strict";t.r(_);var r=t(2),e=Object(r.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"设计原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计原则"}},[v._v("#")]),v._v(" 设计原则")]),v._v(" "),_("p",[v._v("我们在设计一些设计模式时，一般遵循如下七项基本原则，它们分别是:")]),v._v(" "),_("ol",[_("li",[v._v("单一职责原则 (Single Responsibility Principle)")]),v._v(" "),_("li",[v._v("开放-关闭原则 (Open-Closed Principle)")]),v._v(" "),_("li",[v._v("里氏替换原则 (Liskov Substitution Principle)")]),v._v(" "),_("li",[v._v("依赖倒转原则 (Dependence Inversion Principle)")]),v._v(" "),_("li",[v._v("接口隔离原则 (Interface Segregation Principle)")]),v._v(" "),_("li",[v._v("迪米特法则（Law Of Demeter）")]),v._v(" "),_("li",[v._v("组合/聚合复用原则 (Composite/Aggregate Reuse Principle)")])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("标记")]),v._v(" "),_("th",[v._v("设计模式原则名称")]),v._v(" "),_("th",[v._v("简单定义")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("OCP")]),v._v(" "),_("td",[v._v("开闭原则")]),v._v(" "),_("td",[v._v("对扩展开放，对修改关闭")])]),v._v(" "),_("tr",[_("td",[v._v("SRP")]),v._v(" "),_("td",[v._v("单一职责原则")]),v._v(" "),_("td",[v._v("一个类只负责一个功能领域中的相应职责")])]),v._v(" "),_("tr",[_("td",[v._v("LSP")]),v._v(" "),_("td",[v._v("里氏替换原则")]),v._v(" "),_("td",[v._v("所有引用基类的地方必须能透明地使用其子类的对象")])]),v._v(" "),_("tr",[_("td",[v._v("DIP")]),v._v(" "),_("td",[v._v("依赖倒转原则")]),v._v(" "),_("td",[v._v("依赖于抽象，不能依赖于具体实现")])]),v._v(" "),_("tr",[_("td",[v._v("ISP")]),v._v(" "),_("td",[v._v("接口隔离原则")]),v._v(" "),_("td",[v._v("类之间的依赖关系应该建立在最小的接口上")])]),v._v(" "),_("tr",[_("td",[v._v("CARP")]),v._v(" "),_("td",[v._v("合成/聚合复用原则")]),v._v(" "),_("td",[v._v("尽量使用合成/聚合，而不是通过继承达到复用的目的")])]),v._v(" "),_("tr",[_("td",[v._v("LOD")]),v._v(" "),_("td",[v._v("迪米特法则")]),v._v(" "),_("td",[v._v("一个软件实体应当尽可能少的与其他实体发生相互作用")])])])]),v._v(" "),_("p",[v._v("其中，单一职责原则、开闭原则、迪米特法则、里氏代换原则和接口隔离原则就是我们平常熟知的 SOLID。")]),v._v(" "),_("h2",{attrs:{id:"单一职责原则-srp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则-srp"}},[v._v("#")]),v._v(" 单一职责原则 SRP")]),v._v(" "),_("blockquote",[_("p",[v._v("定义：就一个类而言， 应该仅有一个引起它变化的原因。")])]),v._v(" "),_("p",[v._v("不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。")]),v._v(" "),_("h2",{attrs:{id:"开放-关闭原则-ocp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#开放-关闭原则-ocp"}},[v._v("#")]),v._v(" 开放-关闭原则 OCP")]),v._v(" "),_("blockquote",[_("p",[v._v("定义：类、模块、函数等应该是可以拓展的，但是不可修改。")])]),v._v(" "),_("p",[v._v("在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。")]),v._v(" "),_("h2",{attrs:{id:"里氏替换原则-lsp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#里氏替换原则-lsp"}},[v._v("#")]),v._v(" 里氏替换原则 LSP")]),v._v(" "),_("blockquote",[_("p",[v._v("定义：所有引用基类的地方必须能透明地使用其子类的对象。")])]),v._v(" "),_("p",[v._v("任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。")]),v._v(" "),_("h2",{attrs:{id:"依赖倒转原则-dip"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒转原则-dip"}},[v._v("#")]),v._v(" 依赖倒转原则 DIP")]),v._v(" "),_("blockquote",[_("p",[v._v("定义：高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。")])]),v._v(" "),_("p",[v._v("面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。")]),v._v(" "),_("h2",{attrs:{id:"接口隔离原则-isp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离原则-isp"}},[v._v("#")]),v._v(" 接口隔离原则 ISP")]),v._v(" "),_("blockquote",[_("p",[v._v("定义：一个软件实体应当尽可能少地与其他实体发生相互作用。")])]),v._v(" "),_("p",[v._v("每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。")]),v._v(" "),_("h2",{attrs:{id:"迪米特法则-lod"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#迪米特法则-lod"}},[v._v("#")]),v._v(" 迪米特法则 LOD")]),v._v(" "),_("blockquote",[_("p",[v._v("定义：一个类对另一个类的依赖应该建立在最小的接口上。")])]),v._v(" "),_("p",[v._v("一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过 public 方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。")]),v._v(" "),_("h2",{attrs:{id:"组合-聚合复用原则-crp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#组合-聚合复用原则-crp"}},[v._v("#")]),v._v(" 组合/聚合复用原则 CRP")]),v._v(" "),_("blockquote",[_("p",[v._v("定义：在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分; 新的对象通过向这些对象的委派达到复用已有功能的目的。")])]),v._v(" "),_("p",[v._v("尽量使用对象组合/聚合，而不是继承关系达到软件复用的目的。")])])}),[],!1,null,null,null);_.default=e.exports}}]);