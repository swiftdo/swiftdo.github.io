(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{694:function(t,e,v){"use strict";v.r(e);var a=v(8),_=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"设计原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#设计原则"}},[t._v("#")]),t._v(" 设计原则")]),t._v(" "),v("p",[t._v("我们在设计一些设计模式时，一般遵循如下七项基本原则，它们分别是:")]),t._v(" "),v("ol",[v("li",[t._v("单一职责原则 (Single Responsibility Principle)")]),t._v(" "),v("li",[t._v("开放-关闭原则 (Open-Closed Principle)")]),t._v(" "),v("li",[t._v("里氏替换原则 (Liskov Substitution Principle)")]),t._v(" "),v("li",[t._v("依赖倒转原则 (Dependence Inversion Principle)")]),t._v(" "),v("li",[t._v("接口隔离原则 (Interface Segregation Principle)")]),t._v(" "),v("li",[t._v("迪米特法则（Law Of Demeter）")]),t._v(" "),v("li",[t._v("组合/聚合复用原则 (Composite/Aggregate Reuse Principle)")])]),t._v(" "),v("h2",{attrs:{id:"单一职责原则-srp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则-srp"}},[t._v("#")]),t._v(" 单一职责原则 SRP")]),t._v(" "),v("blockquote",[v("p",[t._v("定义：就一个类而言， 应该仅有一个引起它变化的原因。")])]),t._v(" "),v("p",[t._v("不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。")]),t._v(" "),v("h2",{attrs:{id:"开放-关闭原则-ocp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#开放-关闭原则-ocp"}},[t._v("#")]),t._v(" 开放-关闭原则 OCP")]),t._v(" "),v("blockquote",[v("p",[t._v("定义：类、模块、函数等应该是可以拓展的，但是不可修改。")])]),t._v(" "),v("p",[t._v("在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。")]),t._v(" "),v("h2",{attrs:{id:"里氏替换原则-lsp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#里氏替换原则-lsp"}},[t._v("#")]),t._v(" 里氏替换原则 LSP")]),t._v(" "),v("blockquote",[v("p",[t._v("定义：所有引用基类的地方必须能透明地使用其子类的对象。")])]),t._v(" "),v("p",[t._v("任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。")]),t._v(" "),v("h2",{attrs:{id:"依赖倒转原则-dip"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒转原则-dip"}},[t._v("#")]),t._v(" 依赖倒转原则 DIP")]),t._v(" "),v("blockquote",[v("p",[t._v("定义：高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。")])]),t._v(" "),v("p",[t._v("面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。")]),t._v(" "),v("h2",{attrs:{id:"接口隔离原则-isp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离原则-isp"}},[t._v("#")]),t._v(" 接口隔离原则 ISP")]),t._v(" "),v("blockquote",[v("p",[t._v("定义：一个软件实体应当尽可能少地与其他实体发生相互作用。")])]),t._v(" "),v("p",[t._v("每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。")]),t._v(" "),v("h2",{attrs:{id:"迪米特法则-lod"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#迪米特法则-lod"}},[t._v("#")]),t._v(" 迪米特法则 LOD")]),t._v(" "),v("blockquote",[v("p",[t._v("定义：一个类对另一个类的依赖应该建立在最小的接口上。")])]),t._v(" "),v("p",[t._v("一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过 public 方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。")]),t._v(" "),v("h2",{attrs:{id:"组合-聚合复用原则-crp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#组合-聚合复用原则-crp"}},[t._v("#")]),t._v(" 组合/聚合复用原则 CRP")]),t._v(" "),v("blockquote",[v("p",[t._v("定义：在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分; 新的对象通过向这些对象的委派达到复用已有功能的目的。")])]),t._v(" "),v("p",[t._v("尽量使用对象组合/聚合，而不是继承关系达到软件复用的目的。")])])}),[],!1,null,null,null);e.default=_.exports}}]);